name: Daily Commit Summary

# Security: This workflow uses GitHub Secrets for sensitive data
# - OPENAI_API_KEY: Never logged or exposed
# - WEBHOOK_URL: Masked in all outputs
# All sensitive data is masked using ::add-mask:: directive
# Error messages are sanitized to prevent key leakage

on:
    schedule:
        # Runs at 8:45 AM PT (15:45 UTC) Monday-Friday
        - cron: "45 15 * * 1-5"
    workflow_dispatch: # Allow manual triggering for testing

jobs:
    summarize:
        runs-on: ubuntu-latest
        timeout-minutes: 10 # Prevent hanging jobs

        # Security: Disable debug logging to prevent secret exposure
        env:
            ACTIONS_STEP_DEBUG: false
            ACTIONS_RUNNER_DEBUG: false

        steps:
            - name: Security initialization
              run: |
                  # Security: Mask common key patterns if they appear anywhere
                  echo "::add-mask::sk-"
                  echo "::add-mask::api-"
                  echo "::add-mask::key-"
                  echo "::add-mask::token-"
                  echo "::add-mask::bearer"
                  echo "::add-mask::webhook"
                  echo "‚úÖ Security masks initialized"

            - name: Checkout repository
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0 # Fetch all history for accurate log

            - name: Install dependencies
              run: |
                  sudo apt-get update
                  sudo apt-get install -y curl jq

            - name: Generate commit summary
              id: summary
              env:
                  OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
                  GITHUB_TOKEN: ${{ secrets.TOKEN_GITHUB }}
              run: |
                  set -euo pipefail

                  # Security: Mask any potential leaks
                  if [ -n "${OPENAI_API_KEY:-}" ]; then
                    echo "::add-mask::${OPENAI_API_KEY}"
                  fi

                  # Validate API key is present (never echo the actual key)
                  if [ -z "${OPENAI_API_KEY:-}" ]; then
                    echo "‚ùå Error: OPENAI_API_KEY secret is not configured"
                    echo "Please add your OpenAI API key to repository secrets:"
                    echo "1. Go to Settings ‚Üí Secrets and variables ‚Üí Actions"
                    echo "2. Click 'New repository secret'"
                    echo "3. Name: OPENAI_API_KEY"
                    echo "4. Value: Your OpenAI API key"
                    exit 1
                  fi

                  # Security check: Validate key format without exposing it
                  KEY_LENGTH=${#OPENAI_API_KEY}
                  if [ $KEY_LENGTH -lt 10 ]; then
                    echo "‚ùå Error: OPENAI_API_KEY appears to be invalid (too short)"
                    exit 1
                  fi
                  echo "‚úÖ API key validated (length: $KEY_LENGTH characters)"

                  # ---- Time window setup (Pacific Time) ----
                  # Set timezone to Pacific
                  export TZ="America/Los_Angeles"

                  TODAY=$(date +%u)  # weekday number (1=Mon ... 7=Sun)

                  # Handle Monday (include weekend commits) - Extended time window for better coverage
                  if [ "$TODAY" -eq 1 ]; then
                    START=$(date -d "7 days ago 00:00" +"%Y-%m-%d %H:%M:%S")
                  else
                    START=$(date -d "3 days ago 00:00" +"%Y-%m-%d %H:%M:%S")
                  fi

                  END=$(date -d "tomorrow 00:00" +"%Y-%m-%d %H:%M:%S")

                  echo "üîç Debug: Extended time window for better coverage"

                  echo "üìÖ Collecting commits between $START and $END (Pacific Time)"

                  # ---- Collect commits from all repositories ----
                  echo "üîç Fetching commits from all repositories..."

                  # Convert dates to ISO format for GitHub API (Pacific to UTC)
                  # Fix: Properly convert Pacific time to UTC
                  START_ISO=$(TZ="America/Los_Angeles" date -d "$START" +"%Y-%m-%dT%H:%M:%SZ")
                  END_ISO=$(TZ="America/Los_Angeles" date -d "$END" +"%Y-%m-%dT%H:%M:%SZ")

                  echo "üîç Debug: Time window for GitHub API:"
                  echo "  Start (UTC): $START_ISO"
                  echo "  End (UTC): $END_ISO"

                  # Get all repositories the user has access to (increased limit)
                  echo "üîç Fetching repositories from GitHub API..."
                  REPOS_RESPONSE=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
                    -H "Accept: application/vnd.github.v3+json" \
                    "https://api.github.com/user/repos?sort=updated&per_page=200&affiliation=owner,collaborator,organization_member" || echo '[]')

                  # Debug: Check API response for errors
                  if echo "$REPOS_RESPONSE" | jq -e 'has("message")' >/dev/null 2>&1; then
                    ERROR_MSG=$(echo "$REPOS_RESPONSE" | jq -r '.message // "Unknown error"' 2>/dev/null)
                    echo "‚ùå GitHub API Error: $ERROR_MSG"
                    echo "üîç This might be due to:"
                    echo "   - Invalid GITHUB_TOKEN"
                    echo "   - Rate limiting"
                    echo "   - Insufficient permissions"
                    exit 1
                  fi

                  # Debug: Check if we got a valid response
                  if [ "$REPOS_RESPONSE" = "[]" ]; then
                    echo "‚ùå Error: No repositories returned from GitHub API"
                    echo "This could be due to:"
                    echo "- Invalid GITHUB_TOKEN"
                    echo "- No repository access"
                    echo "- API rate limiting"
                    exit 1
                  fi

                  # Extract repository names
                  REPOS=$(echo "$REPOS_RESPONSE" | jq -r '.[].full_name' 2>/dev/null || echo "")

                  # Debug: Show what we found
                  echo "üìã Raw repository response count: $(echo "$REPOS_RESPONSE" | jq 'length' 2>/dev/null || echo "0")"
                  echo "üìã Extracted repository names count: $(echo "$REPOS" | wc -l)"

                  # Show first few repositories for debugging
                  echo "üìã First 5 repositories found:"
                  echo "$REPOS" | head -5 | while read -r repo; do
                    if [ -n "$repo" ]; then
                      echo "   - $repo"
                    fi
                  done

                  # Show total count and verify we have repositories
                  TOTAL_REPO_COUNT=$(echo "$REPOS" | wc -l)
                  echo "üìã Total repositories to process: $TOTAL_REPO_COUNT"

                  if [ "$TOTAL_REPO_COUNT" -eq 0 ]; then
                    echo "‚ùå Error: No repositories found to process"
                    exit 1
                  fi

                  if [ -z "$REPOS" ]; then
                    echo "‚ö†Ô∏è Could not fetch repositories. Falling back to current repo only."
                    # Fallback to current repository
                    COMMITS=$(git log --since="$START" --until="$END" \
                      --pretty=format:"‚Ä¢ %h by %an: %s" \
                      --no-merges || true)
                    COMMIT_COUNT=$(git log --since="$START" --until="$END" \
                      --pretty=format:"%h" --no-merges | wc -l || echo "0")
                  else
                    echo "üìö Found $(echo "$REPOS" | wc -l) repositories to check"
                    
                    ALL_COMMITS=""
                    TOTAL_COMMITS=0
                    REPO_COUNT=0

                    # Iterate through each repository
                    echo "üîÑ Starting repository iteration..."
                    REPO_INDEX=0
                    while IFS= read -r repo; do
                      if [ -n "$repo" ]; then
                        REPO_INDEX=$((REPO_INDEX + 1))
                        echo "üîç Checking repository $REPO_INDEX: $repo"
                        
                        # Get all branches for this repository first
                        echo "  üåø Fetching all branches for $repo..."
                        BRANCHES_RESPONSE=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
                          -H "Accept: application/vnd.github.v3+json" \
                          "https://api.github.com/repos/$repo/branches?per_page=100" || echo '[]')
                        
                        # Extract branch names
                        BRANCHES=$(echo "$BRANCHES_RESPONSE" | jq -r '.[].name' 2>/dev/null || echo "")
                        BRANCH_COUNT=$(echo "$BRANCHES" | wc -l)
                        echo "  üìã Found $BRANCH_COUNT branches in $repo"
                        
                        # Initialize repository commits array
                        REPO_ALL_COMMITS_ARRAY="[]"
                        REPO_COMMIT_COUNT=0
                        
                        # Get commits from each branch
                        if [ -n "$BRANCHES" ]; then
                          while IFS= read -r branch; do
                            if [ -n "$branch" ]; then
                              echo "    üîç Checking branch: $branch"
                              
                              # Get commits for this specific branch
                              BRANCH_COMMITS_RESPONSE=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
                                -H "Accept: application/vnd.github.v3+json" \
                                "https://api.github.com/repos/$repo/commits?since=$START_ISO&until=$END_ISO&per_page=100&sha=$branch" || echo '[]')
                              
                              # Count commits in this branch
                              BRANCH_COMMIT_COUNT=$(echo "$BRANCH_COMMITS_RESPONSE" | jq 'length' 2>/dev/null || echo "0")
                              echo "      üìù Found $BRANCH_COMMIT_COUNT commits in branch $branch"
                              
                              # Merge branch commits into repository array (avoid duplicates by SHA)
                              if [ "$BRANCH_COMMIT_COUNT" -gt 0 ]; then
                                REPO_ALL_COMMITS_ARRAY=$(echo "$REPO_ALL_COMMITS_ARRAY" | jq --argjson branch_commits "$BRANCH_COMMITS_RESPONSE" '. + $branch_commits | unique_by(.sha)' 2>/dev/null || echo "$REPO_ALL_COMMITS_ARRAY")
                                REPO_COMMIT_COUNT=$(echo "$REPO_ALL_COMMITS_ARRAY" | jq 'length' 2>/dev/null || echo "0")
                              fi
                            fi
                          done <<< "$BRANCHES"
                        fi
                        
                        # Use the combined commits from all branches
                        COMMITS_RESPONSE="$REPO_ALL_COMMITS_ARRAY"
                        
                        # Debug: Check if we found any commits
                        if [ "$REPO_COMMIT_COUNT" -eq 0 ]; then
                          echo "  ‚ö†Ô∏è No commits found in any branch for $repo"
                        else
                          echo "  ‚úÖ Found $REPO_COMMIT_COUNT total commits across all branches"
                        fi
                        
                        # Set specific username for filtering (ethank2222)
                        CURRENT_USER="ethank2222"
                        
                        # Debug: Show all commits found (before filtering)
                        TOTAL_COMMITS_IN_REPO=$(echo "$COMMITS_RESPONSE" | jq 'length' 2>/dev/null || echo "0")
                        echo "  üìä Total commits in repo: $TOTAL_COMMITS_IN_REPO"
                        
                        # Show first few commits for debugging
                        echo "  üìã First 3 commits (all authors):"
                        echo "$COMMITS_RESPONSE" | jq -r '.[0:3] | .[] | "    - \(.sha[0:7]) by \(.author.login // .commit.author.name): \(.commit.message | split("\n")[0] | @sh)"' 2>/dev/null | sed "s/'//g" || echo "    No commits found"
                        
                        # Extract commit information, filtering to only ethank2222's commits (check both author and committer)
                        REPO_COMMITS=$(echo "$COMMITS_RESPONSE" | jq -r --arg user "$CURRENT_USER" '.[] | select(.author.login == $user or .committer.login == $user) | "‚Ä¢ \(.sha[0:7]) [\(.commit.author.date | fromdateiso8601 | strftime("%m/%d"))]: \(.commit.message | split("\n")[0] | @sh)"' 2>/dev/null | sed "s/'//g" || echo "")
                        
                        # Count only ethank2222's commits (check both author and committer)
                        REPO_COMMIT_COUNT=$(echo "$COMMITS_RESPONSE" | jq --arg user "$CURRENT_USER" '[.[] | select(.author.login == $user or .committer.login == $user)] | length' 2>/dev/null || echo "0")
                        
                        # Always show repository status, even if no commits
                        echo "  üìù Found $REPO_COMMIT_COUNT of your commits in $repo"
                        
                        # Add repository header and commits (or no commits message)
                        if [ -n "$REPO_COMMITS" ] && [ "$REPO_COMMIT_COUNT" -gt 0 ]; then
                          ALL_COMMITS=$(printf "%s\n\nüìÅ **%s** (%s commits):\n%s" "$ALL_COMMITS" "$repo" "$REPO_COMMIT_COUNT" "$REPO_COMMITS")
                          TOTAL_COMMITS=$((TOTAL_COMMITS + REPO_COMMIT_COUNT))
                        else
                          ALL_COMMITS=$(printf "%s\n\nüìÅ **%s** (0 commits):\n‚Ä¢ No commits in this period" "$ALL_COMMITS" "$repo")
                        fi
                        
                        # Always increment repo count since we're checking every repo
                        REPO_COUNT=$((REPO_COUNT + 1))
                      fi
                    done <<< "$REPOS"

                    echo "‚úÖ Repository iteration complete. Processed $REPO_INDEX repositories."
                    
                    # Verify we processed all repositories
                    if [ "$REPO_INDEX" -ne "$TOTAL_REPO_COUNT" ]; then
                      echo "‚ö†Ô∏è Warning: Expected to process $TOTAL_REPO_COUNT repositories but only processed $REPO_INDEX"
                    else
                      echo "‚úÖ Successfully processed all $TOTAL_REPO_COUNT repositories"
                    fi
                    
                    COMMITS="$ALL_COMMITS"
                    COMMIT_COUNT=$TOTAL_COMMITS
                    
                    echo "üìä Total: $COMMIT_COUNT commits across $REPO_COUNT repositories"
                  fi

                  if [ -z "$COMMITS" ] || [ "$COMMIT_COUNT" -eq 0 ]; then
                    echo "‚ÑπÔ∏è No commits found for previous workday, but will still send webhook."
                    COMMITS="No commits found in the specified period."
                    COMMIT_COUNT=0
                  else
                    echo "Found $COMMIT_COUNT commits to summarize"
                  fi

                  # ---- Prepare OpenAI API request ----
                  # Security: Never echo REQUEST_BODY as it might be logged

                  if [ "$COMMIT_COUNT" -eq 0 ]; then
                    # No commits found - create a simple message
                    REQUEST_BODY=$(jq -n \
                      --arg start "$START" \
                      --arg end "$END" \
                      '{
                        model: "gpt-4o-mini",
                        max_tokens: 100,
                        temperature: 0.3,
                        messages: [{
                          role: "user",
                          content: ($start + " to " + $end + ": No commits found. Return: üìÅ No repositories with commits in this period")
                        }]
                      }')
                  else
                    # Commits found - analyze them
                    REQUEST_BODY=$(jq -n \
                      --arg commits "$COMMITS" \
                      --arg start "$START" \
                      --arg end "$END" \
                      --arg count "$COMMIT_COUNT" \
                      '{
                        model: "gpt-4o-mini",
                        max_tokens: 500,
                        temperature: 0.3,
                        messages: [{
                          role: "user",
                          content: ("Analyze these " + $count + " git commits and create a specific, detailed summary of what was done.\n\nRepository Activity:\n" + $commits + "\n\nCRITICAL INSTRUCTIONS:\n1. BE SPECIFIC - Name the actual features, endpoints, functions, or components\n2. NO DUPLICATES - Combine similar commits into one bullet point\n3. EXTRACT DETAILS - Look at file names and commit messages to infer specific functionality\n\nEXAMPLES OF GOOD DESCRIPTIONS:\n‚Ä¢ Implemented OAuth2 authentication for Google and GitHub providers\n‚Ä¢ Added connection pooling for PostgreSQL with 50 connection limit\n‚Ä¢ Built WebSocket notification system for order status updates\n‚Ä¢ Implemented rate limiting at 100 requests/minute for /api endpoints\n‚Ä¢ Enhanced validation for email (RFC 5322), phone (E.164), and ZIP codes\n‚Ä¢ Fixed payment gateway timeout issue in Stripe integration\n‚Ä¢ Added Winston logging with Datadog integration for error tracking\n\nEXAMPLES OF BAD DESCRIPTIONS:\n‚Ä¢ Updated authentication (too vague)\n‚Ä¢ Integrated additional features (not specific)\n‚Ä¢ Modified configuration files (doesn't say what)\n‚Ä¢ Fixed bugs (which bugs?)\n‚Ä¢ Performed linting (if mentioned once, don't repeat)\n‚Ä¢ Made improvements (too generic)\n\nDEDUPLICATION RULES:\n- If multiple commits do the same thing (e.g., 'lint fixes', 'formatting'), mention it ONCE\n- Group related commits (e.g., 'Added login, logout, and password reset endpoints')\n- If you see 'Update X' and 'Fix X' for same feature, combine them\n\nREQUIRED FORMAT:\nüìÅ Repo Name (X commits):\n‚Ä¢ Specific thing that was implemented with details\n‚Ä¢ Another specific feature or fix\n\nüìÅ Another Repo (Y commits):\n‚Ä¢ Detailed description of what was built\n\nREMEMBER:\n- Be specific about WHAT was implemented (name the feature/function/endpoint)\n- Each bullet point on its own line\n- No duplicate or near-duplicate bullet points\n- Combine related work into single bullets when appropriate\n\nGenerate the summary:")
                        }]
                      }')
                  fi

                  echo "üìù Prepared API request for $COMMIT_COUNT commits"

                  # ---- Call OpenAI API with exponential backoff ----
                  MAX_RETRIES=3
                  RETRY_DELAY=2

                  for i in $(seq 1 $MAX_RETRIES); do
                    echo "Calling OpenAI API (attempt $i/$MAX_RETRIES)..."
                    
                    # Security: Never log the actual request or response that might contain keys
                    RESPONSE=$(curl -s -S --max-time 30 \
                      https://api.openai.com/v1/chat/completions \
                      -H "Authorization: Bearer $OPENAI_API_KEY" \
                      -H "Content-Type: application/json" \
                      -d "$REQUEST_BODY" 2>/dev/null || echo '{"error": "curl failed"}')
                    
                    # Security: Don't echo raw response which might contain sensitive data
                    # Check for rate limit without exposing response
                    if echo "$RESPONSE" | grep -q "rate_limit\|quota_exceeded" 2>/dev/null; then
                      echo "‚ö†Ô∏è Rate limited or quota exceeded. Waiting ${RETRY_DELAY}s..."
                      sleep $RETRY_DELAY
                      RETRY_DELAY=$((RETRY_DELAY * 2))
                      continue
                    fi
                    
                    # Check for authentication errors
                    if echo "$RESPONSE" | grep -q "invalid_api_key\|authentication" 2>/dev/null; then
                      echo "‚ùå Authentication failed. Please check your OPENAI_API_KEY secret."
                      exit 1
                    fi
                    
                    # Extract summary from response (safe to display)
                    SUMMARY=$(echo "$RESPONSE" | jq -r '.choices[0].message.content // empty' 2>/dev/null)
                    
                    if [ -n "$SUMMARY" ]; then
                      echo "‚úÖ Successfully generated summary"
                      
                      # Post-process summary to ensure proper bullet point formatting
                      echo "üîß Post-processing summary for proper markdown formatting..."
                      
                      # Convert any dash (-) to bullet points (‚Ä¢) if they're not already
                      SUMMARY=$(echo "$SUMMARY" | sed 's/^[[:space:]]*-[[:space:]]/‚Ä¢ /g')
                      
                      # Ensure bullet points are properly formatted with line breaks
                      SUMMARY=$(echo "$SUMMARY" | sed 's/^[[:space:]]*‚Ä¢[[:space:]]*/‚Ä¢ /g')
                      
                      # Ensure each repository header is on its own line with proper spacing
                      SUMMARY=$(echo "$SUMMARY" | sed 's/üìÅ/\n\nüìÅ/g' | sed 's/^\n\n//')
                      
                      echo "‚úÖ Summary formatting complete"
                      break
                    fi
                    
                    # Security: Extract error message but sanitize it
                    ERROR=$(echo "$RESPONSE" | jq -r '.error.message // .error // "Unknown error"' 2>/dev/null | \
                      sed 's/sk-[a-zA-Z0-9]*/**REDACTED**/g' | \
                      sed 's/[a-zA-Z0-9]{32,}/**KEY**/g')
                    echo "‚ö†Ô∏è API call failed: ${ERROR:0:100}"  # Truncate error message
                    
                    # Log response status for debugging (without sensitive data)
                    HTTP_STATUS=$(echo "$RESPONSE" | jq -r '.error.status // "unknown"' 2>/dev/null)
                    if [ "$HTTP_STATUS" != "null" ] && [ "$HTTP_STATUS" != "unknown" ]; then
                      echo "üìä HTTP Status: $HTTP_STATUS"
                    fi
                    
                    if [ $i -lt $MAX_RETRIES ]; then
                      echo "Retrying in ${RETRY_DELAY}s..."
                      sleep $RETRY_DELAY
                      RETRY_DELAY=$((RETRY_DELAY * 2))
                    fi
                  done

                  # Fallback if API fails
                  if [ -z "$SUMMARY" ]; then
                    echo "‚ö†Ô∏è Using fallback summary"
                    # Handle case where REPO_COUNT might not be defined (fallback scenario)
                    REPO_COUNT_DISPLAY=${REPO_COUNT:-1}
                    
                    if [ "$COMMIT_COUNT" -eq 0 ]; then
                      if [ "$TODAY" -eq 1 ]; then
                        SUMMARY="üìÅ No repositories with commits over the weekend"
                      else
                        SUMMARY="üìÅ No repositories with commits yesterday"
                      fi
                    else
                      if [ "$TODAY" -eq 1 ]; then
                        SUMMARY="üìÅ Completed $COMMIT_COUNT commits across $REPO_COUNT_DISPLAY repositories over the weekend"
                      else
                        SUMMARY="üìÅ Completed $COMMIT_COUNT commits across $REPO_COUNT_DISPLAY repositories yesterday"
                      fi
                    fi
                    
                    # Apply the same post-processing to fallback summary
                    echo "üîß Post-processing fallback summary for proper markdown formatting..."
                    # Ensure proper line breaks for Teams
                    SUMMARY=$(echo "$SUMMARY" | sed 's/üìÅ/\n\nüìÅ/g' | sed 's/^\n\n//')
                    echo "‚úÖ Fallback summary formatting complete"
                  fi

                  # Security: Final sanitization before saving
                  SUMMARY=$(echo "$SUMMARY" | \
                    sed 's/sk-[a-zA-Z0-9_-]\{20,\}/**REDACTED**/g' | \
                    sed 's/\b[a-fA-F0-9]\{32,\}\b/**KEY**/g')

                  # Save outputs using new syntax
                  echo "SUMMARY<<EOF" >> $GITHUB_OUTPUT
                  echo "$SUMMARY" >> $GITHUB_OUTPUT
                  echo "EOF" >> $GITHUB_OUTPUT
                  echo "SKIP_WEBHOOK=false" >> $GITHUB_OUTPUT
                  echo "TODAY=$TODAY" >> $GITHUB_OUTPUT
                  echo "REPO_COUNT=${REPO_COUNT:-1}" >> $GITHUB_OUTPUT
                  echo "COMMIT_COUNT=$COMMIT_COUNT" >> $GITHUB_OUTPUT

            - name: Send to webhook
              if: steps.summary.outputs.SKIP_WEBHOOK != 'true'
              env:
                  WEBHOOK_URL: ${{ secrets.WEBHOOK_URL }}
                  SUMMARY: ${{ steps.summary.outputs.SUMMARY }}
                  TODAY: ${{ steps.summary.outputs.TODAY }}
                  REPO_COUNT: ${{ steps.summary.outputs.REPO_COUNT }}
                  COMMIT_COUNT: ${{ steps.summary.outputs.COMMIT_COUNT }}
              run: |
                  set -euo pipefail

                  # Security: Mask webhook URL immediately
                  if [ -n "${WEBHOOK_URL:-}" ]; then
                    echo "::add-mask::${WEBHOOK_URL}"
                    # Extract just the service name for safe logging
                    if echo "$WEBHOOK_URL" | grep -q "slack.com"; then
                      echo "üì§ Sending summary to Slack webhook"
                    elif echo "$WEBHOOK_URL" | grep -q "discord.com"; then
                      echo "üì§ Sending summary to Discord webhook"
                    elif echo "$WEBHOOK_URL" | grep -q "office.com"; then
                      echo "üì§ Sending summary to Teams webhook"
                    else
                      echo "üì§ Sending summary to webhook"
                    fi
                  fi

                  # Validate webhook URL exists
                  if [ -z "${WEBHOOK_URL:-}" ]; then
                    echo "‚ö†Ô∏è WEBHOOK_URL secret not configured"
                    echo "Summary was generated but cannot be sent."
                    echo ""
                    echo "To enable webhook notifications:"
                    echo "1. Go to Settings ‚Üí Secrets and variables ‚Üí Actions"
                    echo "2. Click 'New repository secret'"
                    echo "3. Name: WEBHOOK_URL"
                    echo "4. Value: Your Slack/Discord/Teams webhook URL"
                    echo ""
                    echo "Generated summary:"
                    echo "$SUMMARY"
                    exit 0
                  fi

                  echo "üì§ Sending summary to webhook..."

                  # Prepare payload with proper escaping (no sensitive data included)
                  # Adjust message for Monday (weekend commits) vs other days
                  if [ "$COMMIT_COUNT" -eq 0 ]; then
                    if [ "$TODAY" -eq 1 ]; then
                      TITLE="üöÄ **Weekend & Friday Development Summary**"
                    else
                      TITLE="üöÄ **Yesterday's Development Summary**"
                    fi
                  else
                    if [ "$TODAY" -eq 1 ]; then
                      TITLE="üöÄ **Weekend & Friday Development Summary**"
                    else
                      TITLE="üöÄ **Yesterday's Development Summary**"
                    fi
                  fi

                  # Create payload for Teams
                  CURRENT_TIME=$(date -u +"%B %d, %Y at %I:%M %p UTC")
                  WORKFLOW_URL="https://github.com/${GITHUB_REPOSITORY:-unknown}/actions/runs/${GITHUB_RUN_ID:-}"

                  # Escape the summary for JSON and preserve line breaks for Teams
                  # First ensure bullet points have proper line breaks
                  FORMATTED_SUMMARY=$(echo "$SUMMARY" | sed 's/‚Ä¢ /\n‚Ä¢ /g' | sed 's/üìÅ/\n\nüìÅ/g' | sed 's/^\n\n//')
                  # Then escape for JSON while preserving the line breaks
                  ESCAPED_SUMMARY=$(echo "$FORMATTED_SUMMARY" | jq -Rs .)

                  # Detect webhook type based on URL
                  if echo "$WEBHOOK_URL" | grep -q "webhook.office.com/webhookb2"; then
                    echo "üìã Detected native Teams Incoming Webhook"
                    # Native Teams Incoming Webhook - uses simpler format
                    PAYLOAD=$(jq -n \
                      --arg title "$TITLE" \
                      --arg time "$CURRENT_TIME" \
                      --arg repos "$REPO_COUNT" \
                      --arg commits "$COMMIT_COUNT" \
                      --arg period "$([ "$TODAY" -eq 1 ] && echo "Weekend & Friday" || echo "$(date -d "yesterday" +"%B %d, %Y")")" \
                      --argjson summary "$ESCAPED_SUMMARY" \
                      --arg url "$WORKFLOW_URL" \
                      '{
                        "@type": "MessageCard",
                        "@context": "https://schema.org/extensions",
                        "themeColor": "0078D4",
                        "title": $title,
                        "summary": ("Commits: " + $commits + " | Repos: " + $repos),
                        "sections": [
                          {
                            "activityTitle": $time,
                            "facts": [
                              {
                                "name": "üìö Repositories Checked",
                                "value": $repos
                              },
                              {
                                "name": "üíª Commits Found",
                                "value": $commits
                              },
                              {
                                "name": "üìÖ Time Period",
                                "value": $period
                              }
                            ]
                          },
                          {
                            "title": "**Summary of Work Completed**",
                            "text": $summary
                          }
                        ],
                        "potentialAction": [
                          {
                            "@type": "OpenUri",
                            "name": "üîç View Workflow Run",
                            "targets": [
                              {
                                "os": "default",
                                "uri": $url
                              }
                            ]
                          }
                        ]
                      }')
                  else
                    echo "üìã Using Power Automate/Teams Webhook format"
                    # Power Automate or other webhook - use AdaptiveCard format
                    PAYLOAD=$(jq -n \
                      --arg title "$TITLE" \
                      --arg time "$CURRENT_TIME" \
                      --arg repos "$REPO_COUNT" \
                      --arg commits "$COMMIT_COUNT" \
                      --arg period "$([ "$TODAY" -eq 1 ] && echo "Weekend & Friday" || echo "$(date -d "yesterday" +"%B %d, %Y")")" \
                      --argjson summary "$ESCAPED_SUMMARY" \
                      --arg url "$WORKFLOW_URL" \
                      '{
                        type: "message",
                        attachments: [{
                          contentType: "application/vnd.microsoft.card.adaptive",
                          content: {
                            "$schema": "http://adaptivecards.io/schemas/adaptive-card.json",
                            type: "AdaptiveCard",
                            version: "1.3",
                            body: [
                              {
                                type: "Container",
                                style: "emphasis",
                                bleed: true,
                                items: [
                                  {
                                    type: "TextBlock",
                                    text: $title,
                                    size: "Large",
                                    weight: "Bolder",
                                    color: "Accent",
                                    wrap: true
                                  },
                                  {
                                    type: "TextBlock",
                                    text: $time,
                                    size: "Small",
                                    color: "Default",
                                    spacing: "None",
                                    wrap: true
                                  }
                                ]
                              },
                              {
                                type: "FactSet",
                                facts: [
                                  {
                                    title: "üìö Repositories Checked",
                                    value: $repos
                                  },
                                  {
                                    title: "üíª Commits Found",
                                    value: $commits
                                  },
                                  {
                                    title: "üìÖ Time Period",
                                    value: $period
                                  }
                                ],
                                spacing: "Medium"
                              },
                              {
                                type: "Container",
                                style: "default",
                                items: [
                                  {
                                    type: "TextBlock",
                                    text: "**Summary of Work Completed**",
                                    size: "Medium",
                                    weight: "Bolder",
                                    color: "Default",
                                    spacing: "Medium",
                                    wrap: true
                                  },
                                  {
                                    type: "TextBlock",
                                    text: $summary,
                                    wrap: true,
                                    spacing: "Small"
                                  }
                                ]
                              }
                            ],
                            actions: [
                              {
                                type: "Action.OpenUrl",
                                title: "üîç View Workflow Run",
                                url: $url,
                                style: "positive"
                              }
                            ]
                          }
                        }]
                      }')
                  fi

                  # Send with retries and exponential backoff
                  MAX_RETRIES=3
                  RETRY_DELAY=2

                  # Log webhook attempt
                  echo "üì§ Attempting to send webhook..."
                  echo "üìã Using Teams Webhook format with AdaptiveCard"

                  for i in $(seq 1 $MAX_RETRIES); do
                    # Security: Send request without exposing URL in logs
                    HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
                      --max-time 10 \
                      -X POST \
                      -H "Content-Type: application/json; charset=utf-8" \
                      -H "Accept: application/json" \
                      -d "$PAYLOAD" \
                      "$WEBHOOK_URL" 2>/dev/null || echo "000")
                    
                    # Check for success (2xx status codes)
                    if [[ "$HTTP_STATUS" =~ ^2[0-9][0-9]$ ]]; then
                      echo "‚úÖ Webhook delivered successfully (HTTP $HTTP_STATUS)"
                      exit 0
                    fi
                    
                    # Security: Log status without exposing URL
                    echo "‚ö†Ô∏è Webhook delivery failed (HTTP $HTTP_STATUS, attempt $i/$MAX_RETRIES)"
                    
                    if [ $i -lt $MAX_RETRIES ]; then
                      echo "Retrying in ${RETRY_DELAY}s..."
                      sleep $RETRY_DELAY
                      RETRY_DELAY=$((RETRY_DELAY * 2))
                    fi
                  done

                  # Security: Fail without exposing webhook details
                  echo "‚ùå Failed to send webhook after $MAX_RETRIES attempts"
                  echo "Please verify your WEBHOOK_URL secret is correctly configured"
                  echo "Common issues:"
                  echo "- Webhook URL is invalid or expired"
                  echo "- Teams channel permissions are incorrect"
                  echo "- Network connectivity issues"
                  exit 1

            - name: Job summary
              if: always()
              run: |
                  echo "## üìä Daily Commit Summary Job" >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY

                  # Security: Never include sensitive data in summaries
                  if [ "${{ steps.summary.outputs.SKIP_WEBHOOK }}" == "true" ]; then
                    echo "‚ÑπÔ∏è No commits to summarize" >> $GITHUB_STEP_SUMMARY
                  else
                    echo "### Summary Generated:" >> $GITHUB_STEP_SUMMARY
                    echo "**Repositories checked:** ${{ steps.summary.outputs.REPO_COUNT }}" >> $GITHUB_STEP_SUMMARY
                    echo "**Commits found:** ${{ steps.summary.outputs.COMMIT_COUNT }}" >> $GITHUB_STEP_SUMMARY
                    echo '```' >> $GITHUB_STEP_SUMMARY
                    # Security: Only show the generated summary, no API responses or keys
                    SAFE_SUMMARY="${{ steps.summary.outputs.SUMMARY }}"
                    # Additional sanitization: Remove any potential leaked keys
                    SAFE_SUMMARY=$(echo "$SAFE_SUMMARY" | sed 's/sk-[a-zA-Z0-9]*/**REDACTED**/g' | sed 's/[a-fA-F0-9]{32,}/**KEY**/g')
                    
                    # Add production status indicators
                    echo "**Status:** ‚úÖ Production Ready" >> $GITHUB_STEP_SUMMARY
                    echo "**API Provider:** OpenAI GPT-4o-mini" >> $GITHUB_STEP_SUMMARY
                    echo "**Webhook Format:** Microsoft Teams AdaptiveCard" >> $GITHUB_STEP_SUMMARY
                    echo "$SAFE_SUMMARY" >> $GITHUB_STEP_SUMMARY
                    echo '```' >> $GITHUB_STEP_SUMMARY
                  fi

                  echo "" >> $GITHUB_STEP_SUMMARY
                  echo "**Run time:** $(date -u +%Y-%m-%d\ %H:%M:%S) UTC" >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY
                  echo "‚úÖ Security: All sensitive data masked" >> $GITHUB_STEP_SUMMARY
