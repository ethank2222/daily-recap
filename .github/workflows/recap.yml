name: Daily Commit Summary

# Security: This workflow uses GitHub Secrets for sensitive data
# - OPENAI_API_KEY: Never logged or exposed
# - WEBHOOK_URL: Masked in all outputs
# All sensitive data is masked using ::add-mask:: directive
# Error messages are sanitized to prevent key leakage

on:
  schedule:
    # Runs at 8:45 AM PT (15:45 UTC) Monday-Friday
    - cron: "45 15 * * 1-5"
  workflow_dispatch: # Allow manual triggering for testing

jobs:
  summarize:
    runs-on: ubuntu-latest
    timeout-minutes: 10 # Prevent hanging jobs

    # Security: Disable debug logging to prevent secret exposure
    env:
      ACTIONS_STEP_DEBUG: false
      ACTIONS_RUNNER_DEBUG: false

    steps:
      - name: Security initialization
        run: |
          # Security: Mask common key patterns if they appear anywhere
          echo "::add-mask::sk-"
          echo "::add-mask::api-"
          echo "::add-mask::key-"
          echo "::add-mask::token-"
          echo "::add-mask::bearer"
          echo "::add-mask::webhook"
          echo "‚úÖ Security masks initialized"

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for accurate log

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y curl jq

      - name: Generate commit summary
        id: summary
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          # Security: Mask any potential leaks
          if [ -n "${OPENAI_API_KEY:-}" ]; then
            echo "::add-mask::${OPENAI_API_KEY}"
          fi

          # Validate API key is present (never echo the actual key)
          if [ -z "${OPENAI_API_KEY:-}" ]; then
            echo "‚ùå Error: OPENAI_API_KEY secret is not configured"
            echo "Please add your OpenAI API key to repository secrets:"
            echo "1. Go to Settings ‚Üí Secrets and variables ‚Üí Actions"
            echo "2. Click 'New repository secret'"
            echo "3. Name: OPENAI_API_KEY"
            echo "4. Value: Your OpenAI API key"
            exit 1
          fi

          # Security check: Validate key format without exposing it
          KEY_LENGTH=${#OPENAI_API_KEY}
          if [ $KEY_LENGTH -lt 10 ]; then
            echo "‚ùå Error: OPENAI_API_KEY appears to be invalid (too short)"
            exit 1
          fi
          echo "‚úÖ API key validated (length: $KEY_LENGTH characters)"

          # ---- Time window setup (Pacific Time) ----
          # Set timezone to Pacific
          export TZ="America/Los_Angeles"

          TODAY=$(date +%u)  # weekday number (1=Mon ... 7=Sun)

          # Handle Monday (include weekend commits)
          if [ "$TODAY" -eq 1 ]; then
            START=$(date -d "3 days ago 00:00" +"%Y-%m-%d %H:%M:%S")
          else
            START=$(date -d "1 day ago 00:00" +"%Y-%m-%d %H:%M:%S")
          fi

          END=$(date -d "today 00:00" +"%Y-%m-%d %H:%M:%S")

          echo "üìÖ Collecting commits between $START and $END (Pacific Time)"

          # ---- Collect commits from all repositories ----
          echo "üîç Fetching commits from all repositories..."

          # Convert dates to ISO format for GitHub API (Pacific to UTC)
          START_ISO=$(date -u -d "$START" +"%Y-%m-%dT%H:%M:%SZ")
          END_ISO=$(date -u -d "$END" +"%Y-%m-%dT%H:%M:%SZ")

          # Get all repositories the user has access to
          REPOS_RESPONSE=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/user/repos?type=all&sort=updated&per_page=100" || echo '[]')

          # Extract repository names
          REPOS=$(echo "$REPOS_RESPONSE" | jq -r '.[].full_name' 2>/dev/null || echo "")

          if [ -z "$REPOS" ]; then
            echo "‚ö†Ô∏è Could not fetch repositories. Falling back to current repo only."
            # Fallback to current repository
            COMMITS=$(git log --since="$START" --until="$END" \
              --pretty=format:"‚Ä¢ %h by %an: %s" \
              --no-merges || true)
            COMMIT_COUNT=$(git log --since="$START" --until="$END" \
              --pretty=format:"%h" --no-merges | wc -l || echo "0")
          else
            echo "üìö Found $(echo "$REPOS" | wc -l) repositories to check"
            
            ALL_COMMITS=""
            TOTAL_COMMITS=0
            REPO_COUNT=0

            # Iterate through each repository
            while IFS= read -r repo; do
              if [ -n "$repo" ]; then
                echo "üîç Checking repository: $repo"
                
                                 # Get commits for this repository in the time window (all branches)
                 COMMITS_RESPONSE=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
                   -H "Accept: application/vnd.github.v3+json" \
                   "https://api.github.com/repos/$repo/commits?since=$START_ISO&until=$END_ISO&per_page=100&sha=all" || echo '[]')
                
                # Get current user's username for filtering
                CURRENT_USER=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
                  -H "Accept: application/vnd.github.v3+json" \
                  "https://api.github.com/user" | jq -r '.login' 2>/dev/null || echo "")
                
                                 # Extract commit information, filtering to only current user's commits
                 if [ -n "$CURRENT_USER" ]; then
                   REPO_COMMITS=$(echo "$COMMITS_RESPONSE" | jq -r --arg user "$CURRENT_USER" '.[] | select(.author.login == $user) | "‚Ä¢ \(.sha[0:7]) [\(.commit.author.date | fromdateiso8601 | strftime("%m/%d"))]: \(.commit.message | split("\n")[0])"' 2>/dev/null || echo "")
                 else
                   # Fallback if we can't get current user - skip this repo
                   echo "  ‚ö†Ô∏è Could not determine current user, skipping $repo"
                   REPO_COMMITS=""
                 fi
                
                # Count only current user's commits
                if [ -n "$CURRENT_USER" ]; then
                  REPO_COMMIT_COUNT=$(echo "$COMMITS_RESPONSE" | jq --arg user "$CURRENT_USER" '[.[] | select(.author.login == $user)] | length' 2>/dev/null || echo "0")
                else
                  REPO_COMMIT_COUNT=0
                fi
                
                # Always show repository status, even if no commits
                echo "  üìù Found $REPO_COMMIT_COUNT of your commits in $repo"
                
                # Add repository header and commits (or no commits message)
                if [ -n "$REPO_COMMITS" ] && [ "$REPO_COMMIT_COUNT" -gt 0 ]; then
                  ALL_COMMITS="${ALL_COMMITS}\n\nüìÅ **$repo** ($REPO_COMMIT_COUNT commits):\n$REPO_COMMITS"
                  TOTAL_COMMITS=$((TOTAL_COMMITS + REPO_COMMIT_COUNT))
                else
                  ALL_COMMITS="${ALL_COMMITS}\n\nüìÅ **$repo** (0 commits):\n‚Ä¢ No commits in this period"
                fi
                
                # Always increment repo count since we're checking every repo
                REPO_COUNT=$((REPO_COUNT + 1))
              fi
            done <<< "$REPOS"

            COMMITS="$ALL_COMMITS"
            COMMIT_COUNT=$TOTAL_COMMITS
            
            echo "üìä Total: $COMMIT_COUNT commits across $REPO_COUNT repositories"
          fi

          if [ -z "$COMMITS" ] || [ "$COMMIT_COUNT" -eq 0 ]; then
            echo "‚ÑπÔ∏è No commits found for previous workday, but will still send webhook."
            COMMITS="No commits found in the specified period."
            COMMIT_COUNT=0
          else
            echo "Found $COMMIT_COUNT commits to summarize"
          fi

          # ---- Prepare OpenAI API request ----
          # Security: Never echo REQUEST_BODY as it might be logged

                     if [ "$COMMIT_COUNT" -eq 0 ]; then
             # No commits found - create a simple message
             REQUEST_BODY=$(jq -n \
               --arg start "$START" \
               --arg end "$END" \
               '{
                 model: "gpt-4o-mini",
                 max_tokens: 100,
                 temperature: 0.3,
                 messages: [{
                   role: "user",
                   content: "No git commits found between " + $start + " and " + $end + ". Create a brief message: üìÅ No repositories with commits in this period"
                 }]
               }')
          else
                         # Commits found - analyze them
             REQUEST_BODY=$(jq -n \
               --arg commits "$COMMITS" \
               --arg start "$START" \
               --arg end "$END" \
               --arg count "$COMMIT_COUNT" \
               '{
                 model: "gpt-4o-mini",
                 max_tokens: 300,
                 temperature: 0.3,
                 messages: [{
                   role: "user",
                   content: "Create a concise daily summary from these " + $count + " git commits.\n\nRepository Activity:\n" + $commits + "\n\nREQUIREMENTS:\n- List ONLY repository names and commit counts\n- Include ONLY the main functionalities you worked on\n- Keep it brief and technical\n- No explanations or fluff\n- Focus on what was actually built/fixed/improved\n\nFORMAT:\nüìÅ Repo Name (X commits):\n‚Ä¢ Functionality 1\n‚Ä¢ Functionality 2\n\nüìÅ Another Repo (Y commits):\n‚Ä¢ Functionality 3\n\nGenerate the summary:"
                 }]
               }')
          fi

          echo "üìù Prepared API request for $COMMIT_COUNT commits"

          # ---- Call OpenAI API with exponential backoff ----
          MAX_RETRIES=3
          RETRY_DELAY=2

          for i in $(seq 1 $MAX_RETRIES); do
            echo "Calling OpenAI API (attempt $i/$MAX_RETRIES)..."
            
            # Security: Never log the actual request or response that might contain keys
            RESPONSE=$(curl -s -S --max-time 30 \
              https://api.openai.com/v1/chat/completions \
              -H "Authorization: Bearer $OPENAI_API_KEY" \
              -H "Content-Type: application/json" \
              -d "$REQUEST_BODY" 2>/dev/null || echo '{"error": "curl failed"}')
            
            # Security: Don't echo raw response which might contain sensitive data
            # Check for rate limit without exposing response
            if echo "$RESPONSE" | grep -q "rate_limit\|quota_exceeded" 2>/dev/null; then
              echo "‚ö†Ô∏è Rate limited or quota exceeded. Waiting ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
              RETRY_DELAY=$((RETRY_DELAY * 2))
              continue
            fi
            
            # Check for authentication errors
            if echo "$RESPONSE" | grep -q "invalid_api_key\|authentication" 2>/dev/null; then
              echo "‚ùå Authentication failed. Please check your OPENAI_API_KEY secret."
              exit 1
            fi
            
            # Extract summary from response (safe to display)
            SUMMARY=$(echo "$RESPONSE" | jq -r '.choices[0].message.content // empty' 2>/dev/null)
            
            if [ -n "$SUMMARY" ]; then
              echo "‚úÖ Successfully generated summary"
              break
            fi
            
            # Security: Extract error message but sanitize it
            ERROR=$(echo "$RESPONSE" | jq -r '.error.message // .error // "Unknown error"' 2>/dev/null | \
              sed 's/sk-[a-zA-Z0-9]*/**REDACTED**/g' | \
              sed 's/[a-zA-Z0-9]{32,}/**KEY**/g')
            echo "‚ö†Ô∏è API call failed: ${ERROR:0:100}"  # Truncate error message
            
            # Log response status for debugging (without sensitive data)
            HTTP_STATUS=$(echo "$RESPONSE" | jq -r '.error.status // "unknown"' 2>/dev/null)
            if [ "$HTTP_STATUS" != "null" ] && [ "$HTTP_STATUS" != "unknown" ]; then
              echo "üìä HTTP Status: $HTTP_STATUS"
            fi
            
            if [ $i -lt $MAX_RETRIES ]; then
              echo "Retrying in ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
              RETRY_DELAY=$((RETRY_DELAY * 2))
            fi
          done

                     # Fallback if API fails
           if [ -z "$SUMMARY" ]; then
             echo "‚ö†Ô∏è Using fallback summary"
             # Handle case where REPO_COUNT might not be defined (fallback scenario)
             REPO_COUNT_DISPLAY=${REPO_COUNT:-1}
             
             if [ "$COMMIT_COUNT" -eq 0 ]; then
               if [ "$TODAY" -eq 1 ]; then
                 SUMMARY="üìÅ No repositories with commits over the weekend"
               else
                 SUMMARY="üìÅ No repositories with commits yesterday"
               fi
             else
               if [ "$TODAY" -eq 1 ]; then
                 SUMMARY="üìÅ Completed $COMMIT_COUNT commits across $REPO_COUNT_DISPLAY repositories over the weekend"
               else
                 SUMMARY="üìÅ Completed $COMMIT_COUNT commits across $REPO_COUNT_DISPLAY repositories yesterday"
               fi
             fi
           fi

          # Security: Final sanitization before saving
          SUMMARY=$(echo "$SUMMARY" | \
            sed 's/sk-[a-zA-Z0-9_-]\{20,\}/**REDACTED**/g' | \
            sed 's/\b[a-fA-F0-9]\{32,\}\b/**KEY**/g')

          # Save outputs using new syntax
          echo "SUMMARY<<EOF" >> $GITHUB_OUTPUT
          echo "$SUMMARY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "SKIP_WEBHOOK=false" >> $GITHUB_OUTPUT
          echo "TODAY=$TODAY" >> $GITHUB_OUTPUT
          echo "REPO_COUNT=${REPO_COUNT:-1}" >> $GITHUB_OUTPUT
          echo "COMMIT_COUNT=$COMMIT_COUNT" >> $GITHUB_OUTPUT

      - name: Send to webhook
        if: steps.summary.outputs.SKIP_WEBHOOK != 'true'
        env:
          WEBHOOK_URL: ${{ secrets.WEBHOOK_URL }}
          SUMMARY: ${{ steps.summary.outputs.SUMMARY }}
          TODAY: ${{ steps.summary.outputs.TODAY }}
          REPO_COUNT: ${{ steps.summary.outputs.REPO_COUNT }}
          COMMIT_COUNT: ${{ steps.summary.outputs.COMMIT_COUNT }}
        run: |
          set -euo pipefail

          # Security: Mask webhook URL immediately
          if [ -n "${WEBHOOK_URL:-}" ]; then
            echo "::add-mask::${WEBHOOK_URL}"
            # Extract just the service name for safe logging
            if echo "$WEBHOOK_URL" | grep -q "slack.com"; then
              echo "üì§ Sending summary to Slack webhook"
            elif echo "$WEBHOOK_URL" | grep -q "discord.com"; then
              echo "üì§ Sending summary to Discord webhook"
            elif echo "$WEBHOOK_URL" | grep -q "office.com"; then
              echo "üì§ Sending summary to Teams webhook"
            else
              echo "üì§ Sending summary to webhook"
            fi
          fi

          # Validate webhook URL exists
          if [ -z "${WEBHOOK_URL:-}" ]; then
            echo "‚ö†Ô∏è WEBHOOK_URL secret not configured"
            echo "Summary was generated but cannot be sent."
            echo ""
            echo "To enable webhook notifications:"
            echo "1. Go to Settings ‚Üí Secrets and variables ‚Üí Actions"
            echo "2. Click 'New repository secret'"
            echo "3. Name: WEBHOOK_URL"
            echo "4. Value: Your Slack/Discord/Teams webhook URL"
            echo ""
            echo "Generated summary:"
            echo "$SUMMARY"
            exit 0
          fi

          echo "üì§ Sending summary to webhook..."

          # Prepare payload with proper escaping (no sensitive data included)
          # Adjust message for Monday (weekend commits) vs other days
          if [ "$COMMIT_COUNT" -eq 0 ]; then
            if [ "$TODAY" -eq 1 ]; then
              TITLE="üöÄ **Weekend & Friday Development Summary**"
            else
              TITLE="üöÄ **Yesterday's Development Summary**"
            fi
          else
            if [ "$TODAY" -eq 1 ]; then
              TITLE="üöÄ **Weekend & Friday Development Summary**"
            else
              TITLE="üöÄ **Yesterday's Development Summary**"
            fi
          fi

          # Security: Payload only contains the summary, no keys or URLs
          # Enhanced Teams webhook payload with rich formatting
          CURRENT_TIME=$(date -u +"%B %d, %Y at %I:%M %p UTC")
          TIME_PERIOD=$(if [ "$COMMIT_COUNT" -gt 0 ]; then echo "Active development"; else echo "Planning/meetings focus"; fi)

          PAYLOAD=$(jq -n \
            --arg title "$TITLE" \
            --arg summary "$SUMMARY" \
            --arg repo_count "$REPO_COUNT" \
            --arg commit_count "$COMMIT_COUNT" \
            --arg current_time "$CURRENT_TIME" \
            --arg time_period "$TIME_PERIOD" \
            --arg subtitle "Generated on $CURRENT_TIME" \
            '{
              "@type": "MessageCard",
              "@context": "http://schema.org/extensions",
              "themeColor": "0076D7",
              "summary": $title,
              "sections": [
                {
                  "activityTitle": $title,
                  "activitySubtitle": $subtitle,
                  "activityImage": "https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png",
                  "facts": [
                    {
                      "name": "üìö Repositories Checked",
                      "value": $repo_count
                    },
                    {
                      "name": "üíª Commits Found",
                      "value": $commit_count
                    },
                    {
                      "name": "‚è∞ Time Period",
                      "value": $time_period
                    }
                  ],
                  "text": $summary
                }
              ],
              "potentialAction": [
                {
                  "@type": "OpenUri",
                  "name": "üîç View Repository",
                  "targets": [
                    {
                      "os": "default",
                      "uri": "https://github.com"
                    }
                  ]
                }
              ]
            }')

          # Send with retries and exponential backoff
          MAX_RETRIES=3
          RETRY_DELAY=2

          # Log webhook attempt
          echo "üì§ Attempting to send webhook to Teams..."

          for i in $(seq 1 $MAX_RETRIES); do
            # Security: Send request without exposing URL in logs
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
              --max-time 10 \
              -X POST \
              -H "Content-Type: application/json" \
              -d "$PAYLOAD" \
              "$WEBHOOK_URL" 2>/dev/null || echo "000")
            
            # Check for success (2xx status codes)
            if [[ "$HTTP_STATUS" =~ ^2[0-9][0-9]$ ]]; then
              echo "‚úÖ Webhook delivered successfully (HTTP $HTTP_STATUS)"
              exit 0
            fi
            
            # Security: Log status without exposing URL
            echo "‚ö†Ô∏è Webhook delivery failed (HTTP $HTTP_STATUS, attempt $i/$MAX_RETRIES)"
            
            if [ $i -lt $MAX_RETRIES ]; then
              echo "Retrying in ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
              RETRY_DELAY=$((RETRY_DELAY * 2))
            fi
          done

          # Security: Fail without exposing webhook details
          echo "‚ùå Failed to send webhook after $MAX_RETRIES attempts"
          echo "Please verify your WEBHOOK_URL secret is correctly configured"
          echo "Common issues:"
          echo "- Webhook URL is invalid or expired"
          echo "- Teams channel permissions are incorrect"
          echo "- Network connectivity issues"
          exit 1

      - name: Job summary
        if: always()
        run: |
          echo "## üìä Daily Commit Summary Job" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Security: Never include sensitive data in summaries
          if [ "${{ steps.summary.outputs.SKIP_WEBHOOK }}" == "true" ]; then
            echo "‚ÑπÔ∏è No commits to summarize" >> $GITHUB_STEP_SUMMARY
          else
            echo "### Summary Generated:" >> $GITHUB_STEP_SUMMARY
            echo "**Repositories checked:** ${{ steps.summary.outputs.REPO_COUNT }}" >> $GITHUB_STEP_SUMMARY
            echo "**Commits found:** ${{ steps.summary.outputs.COMMIT_COUNT }}" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            # Security: Only show the generated summary, no API responses or keys
            SAFE_SUMMARY="${{ steps.summary.outputs.SUMMARY }}"
            # Additional sanitization: Remove any potential leaked keys
            SAFE_SUMMARY=$(echo "$SAFE_SUMMARY" | sed 's/sk-[a-zA-Z0-9]*/**REDACTED**/g' | sed 's/[a-fA-F0-9]{32,}/**KEY**/g')
            
            # Add production status indicators
            echo "**Status:** ‚úÖ Production Ready" >> $GITHUB_STEP_SUMMARY
            echo "**API Provider:** OpenAI GPT-4o-mini" >> $GITHUB_STEP_SUMMARY
            echo "**Webhook Format:** Microsoft Teams MessageCard" >> $GITHUB_STEP_SUMMARY
            echo "$SAFE_SUMMARY" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Run time:** $(date -u +%Y-%m-%d\ %H:%M:%S) UTC" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ Security: All sensitive data masked" >> $GITHUB_STEP_SUMMARY
